<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic Weather Station Vs Manual Weather Stationl </title>
    <!-- Plotly.js CDN -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- SheetJS CDN for Excel parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
        }
        .description {
            color: #666;
            font-size: 16px;
            margin-bottom: 20px;
        }
        #plot {
            width: 100%;
            height: 700px;
            margin-top: 20px;
        }
        .instructions {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        .input-section {
            margin-bottom: 20px;
        }
        input[type="file"], select, input[type="date"] {
            margin: 5px;
            padding: 5px;
        }
        button {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Automatic Weather Station Vs Manual Weather Station</h1>
        <div class="description">
            Upload an Excel file, select a sheet, comparison set, and date range to plot.
            Use the mouse to zoom, drag to pan, or use the range slider and buttons.
        </div>
        <div class="input-section">
            <input type="file" id="excelFile" accept=".xlsx" onchange="populateSheetOptions()">
            <select id="sheetSelect" disabled>
                <option value="">Select a sheet...</option>
            </select>
            <select id="comparisonSelect" disabled>
                <option value="">Select comparison...</option>
                <option value="RH_AWS vs RH_Manual">RH_AWS vs RH_Manual</option>
                <option value="Tsec_AWS vs Tsec_Manual">Tsec_AWS vs Tsec_Manual</option>
                <option value="Td_AWS vs Td_Manual">Td_AWS vs Td_Manual</option>
                <option value="Tmin_AWS vs Tmin_Manual">Tmin_AWS vs Tmin_Manual</option>
                <option value="Tmax_AWS vs Tmax_Manual">Tmax_AWS vs Tmax_Manual</option>
                <option value="Rainfall_AWS vs Rainfall_Manual">Rainfall_AWS vs Rainfall_Manual</option>
            </select>
            <input type="date" id="startDate" value="2025-10-19" placeholder="Start Date">
            <input type="date" id="endDate" value="2025-10-19" placeholder="End Date">
            <button id="loadAndPlot" disabled>Load and Plot</button>
        </div>
        <div id="plot"></div>
        <div class="instructions">
            Zoom: Click and drag or use the mouse wheel. | Range Slider: Adjust below the plot. | Buttons: Select time ranges.
            <br><span class="error-message" id="errorMessage"></span>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded');

            // Function to convert decimal hours to HH:MM format
            function decimalHoursToHHMM(decimalHours) {
                if (typeof decimalHours !== 'number' || !isFinite(decimalHours)) return null;
                const hours = Math.floor(decimalHours * 24);
                const minutes = Math.round((decimalHours * 24 - hours) * 60);
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }

            // Function to combine date and time into DD/MM/YYYY HH:MM
            function combineDateTime(dateStr, timeDecimal) {
                if (!dateStr || typeof timeDecimal !== 'number' || !isFinite(timeDecimal)) return null;
                const timeStr = decimalHoursToHHMM(timeDecimal);
                if (!timeStr) return null;
                return `${dateStr} ${timeStr}`;
            }

            // Function to parse DD/MM/YYYY HH:MM to Date object
            function parseDateTime(dateTimeStr) {
                if (!dateTimeStr || typeof dateTimeStr !== 'string') return null;
                const [datePart, timePart] = dateTimeStr.split(' ');
                if (!datePart || !timePart) return null;
                const [day, month, year] = datePart.split('/').map(Number);
                const [hours, minutes] = timePart.split(':').map(Number);
                if (isNaN(day) || isNaN(month) || isNaN(year) || isNaN(hours) || isNaN(minutes)) return null;
                return new Date(year, month - 1, day, hours, minutes);
            }

            // Function to populate sheet options and handle input changes
            window.populateSheetOptions = function() {
                console.log('Populating sheet options');
                const fileInput = document.getElementById('excelFile');
                const sheetSelect = document.getElementById('sheetSelect');
                const loadButton = document.getElementById('loadAndPlot');
                const comparisonSelect = document.getElementById('comparisonSelect');
                const startDateInput = document.getElementById('startDate');
                const endDateInput = document.getElementById('endDate');
                const errorMessage = document.getElementById('errorMessage');

                if (!fileInput.files.length) {
                    sheetSelect.disabled = true;
                    loadButton.disabled = true;
                    comparisonSelect.disabled = true;
                    sheetSelect.innerHTML = '<option value="">Select a sheet...</option>';
                    errorMessage.textContent = '';
                    console.log('No file selected');
                    return;
                }

                const file = fileInput.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    console.log('File loaded, parsing workbook');
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellText: false, cellDates: false });
                    sheetSelect.innerHTML = '<option value="">Select a sheet...</option>';
                    workbook.SheetNames.forEach(sheet => {
                        const option = document.createElement('option');
                        option.value = sheet;
                        option.textContent = sheet;
                        sheetSelect.appendChild(option);
                    });
                    sheetSelect.disabled = false;
                    comparisonSelect.disabled = false;
                    updateLoadButtonState();
                    errorMessage.textContent = '';
                    console.log('Sheets populated:', workbook.SheetNames);
                };

                reader.onerror = function() {
                    errorMessage.textContent = 'Error reading the Excel file.';
                    console.error('File read error');
                    sheetSelect.disabled = true;
                    loadButton.disabled = true;
                    comparisonSelect.disabled = true;
                    sheetSelect.innerHTML = '<option value="">Select a sheet...</option>';
                };

                reader.readAsArrayBuffer(file);
            };

            // Function to update Load and Plot button state
            function updateLoadButtonState() {
                const fileInput = document.getElementById('excelFile');
                const sheetSelect = document.getElementById('sheetSelect');
                const comparisonSelect = document.getElementById('comparisonSelect');
                const startDateInput = document.getElementById('startDate');
                const endDateInput = document.getElementById('endDate');
                const loadButton = document.getElementById('loadAndPlot');

                const hasFile = fileInput.files.length > 0;
                const hasSheet = sheetSelect.value !== '';
                const hasComparison = comparisonSelect.value !== '';
                const hasStartDate = startDateInput.value !== '';
                const hasEndDate = endDateInput.value !== '';

                loadButton.disabled = !(hasFile && hasSheet && hasComparison && hasStartDate && hasEndDate);
            }

            // Add event listeners to update button state
            document.getElementById('sheetSelect').addEventListener('change', updateLoadButtonState);
            document.getElementById('comparisonSelect').addEventListener('change', updateLoadButtonState);
            document.getElementById('startDate').addEventListener('change', updateLoadButtonState);
            document.getElementById('endDate').addEventListener('change', updateLoadButtonState);

            // Function to load Excel file and plot
            const loadAndPlotButton = document.getElementById('loadAndPlot');
            loadAndPlotButton.addEventListener('click', function() {
                console.log('Load and Plot button clicked');
                const fileInput = document.getElementById('excelFile');
                const sheetSelect = document.getElementById('sheetSelect');
                const comparisonSelect = document.getElementById('comparisonSelect');
                const startDateInput = document.getElementById('startDate');
                const endDateInput = document.getElementById('endDate');
                const errorMessage = document.getElementById('errorMessage');

                if (!fileInput.files.length) {
                    errorMessage.textContent = 'Please upload an Excel file.';
                    console.log('No file uploaded');
                    return;
                }
                if (!sheetSelect.value) {
                    errorMessage.textContent = 'Please select a sheet.';
                    console.log('No sheet selected');
                    return;
                }
                if (!comparisonSelect.value) {
                    errorMessage.textContent = 'Please select a comparison.';
                    console.log('No comparison selected');
                    return;
                }
                if (!startDateInput.value || !endDateInput.value) {
                    errorMessage.textContent = 'Please select both start and end dates.';
                    console.log('No dates selected');
                    return;
                }

                const startDate = new Date(startDateInput.value);
                const endDate = new Date(endDateInput.value);
                endDate.setHours(23, 59, 59, 999);

                if (endDate < startDate) {
                    errorMessage.textContent = 'End date must be on or after start date.';
                    console.log('Invalid date range:', startDate, endDate);
                    return;
                }

                if (isNaN(endDate.getTime()) || isNaN(startDate.getTime())) {
                    errorMessage.textContent = 'Invalid date format. Please use YYYY-MM-DD.';
                    console.log('Invalid dates:', { startDate, endDate });
                    return;
                }

                const file = fileInput.files[0];
                const sheetName = sheetSelect.value;
                const comparison = comparisonSelect.value.split(' vs ');
                const reader = new FileReader();

                reader.onload = function(e) {
                    console.log('Processing file for sheet:', sheetName);
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellText: false, cellDates: false });
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null, raw: true });

                    console.log('Raw JSON Data:', jsonData);
                    console.log('Header Row:', jsonData[0]);
                    console.log('First Data Row Sample:', jsonData[1]);

                    // Skip header row (row 1) and take data from row 2 onwards
                    const headerRow = jsonData[0]; // Row 1 is the header row (0-based index 0)
                    const dataRows = jsonData.slice(1); // Row 2 onwards (0-based index 1)

                    if (!headerRow || headerRow.length < 14) { // Ensure enough columns (N is index 13)
                        errorMessage.textContent = 'Invalid data: Missing headers in row 1 or insufficient columns.';
                        console.log('Invalid header row:', headerRow);
                        return;
                    }

                    // Extract date, time, and data columns with strict validation
                    const dates = dataRows.map(row => {
                        const val = row[0];
                        if (typeof val === 'number' && isFinite(val)) {
                            // Convert Excel serial date to DD/MM/YYYY with debug
                            const excelDate = new Date((val - 25569) * 86400000); // Adjust for Excel's base date (25569 days from 1970-01-01)
                            const day = String(excelDate.getDate()).padStart(2, '0');
                            const month = String(excelDate.getMonth() + 1).padStart(2, '0'); // Months are 0-based
                            const year = excelDate.getFullYear();
                            const formattedDate = `${day}/${month}/${year}`;
                            console.log(`Serial ${val} converted to ${formattedDate} (JavaScript Date: ${excelDate})`);
                            return formattedDate;
                        }
                        return typeof val === 'string' && val.match(/^\d{2}\/\d{2}\/\d{4}$/) ? val : null;
                    }); // Date (DD/MM/YYYY)
                    const times = dataRows.map(row => {
                        const val = row[1];
                        return typeof val === 'number' && isFinite(val) && val >= 0 && val < 1 ? val : null;
                    }); // Time (decimal hours)
                    const colC = dataRows.map(row => {
                        const val = row[2];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // RH_AWS
                    const colD = dataRows.map(row => {
                        const val = row[3];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // RH_Manual
                    const colE = dataRows.map(row => {
                        const val = row[4];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Tsec_AWS
                    const colF = dataRows.map(row => {
                        const val = row[5];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Tsec_Manual
                    const colG = dataRows.map(row => {
                        const val = row[6];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Td_AWS
                    const colH = dataRows.map(row => {
                        const val = row[7];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Td_Manual
                    const colI = dataRows.map(row => {
                        const val = row[8];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Tmin_AWS
                    const colJ = dataRows.map(row => {
                        const val = row[9];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Tmin_Manual
                    const colK = dataRows.map(row => {
                        const val = row[10];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Tmax_AWS
                    const colL = dataRows.map(row => {
                        const val = row[11];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Tmax_Manual
                    const colM = dataRows.map(row => {
                        const val = row[12];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Rainfall_AWS
                    const colN = dataRows.map(row => {
                        const val = row[13];
                        return val !== null && val !== undefined && typeof val === 'number' && isFinite(val) ? val : null;
                    }); // Rainfall_Manual

                    // Log raw column data for debugging
                    console.log('Raw column data:', { 
                        dates: dates.slice(0, 5), 
                        times: times.slice(0, 5), 
                        colC: colC.slice(0, 5), 
                        colD: colD.slice(0, 5), 
                        colE: colE.slice(0, 5), 
                        colF: colF.slice(0, 5), 
                        colG: colG.slice(0, 5), 
                        colH: colH.slice(0, 5), 
                        colI: colI.slice(0, 5), 
                        colJ: colJ.slice(0, 5), 
                        colK: colK.slice(0, 5), 
                        colL: colL.slice(0, 5), 
                        colM: colM.slice(0, 5), 
                        colN: colN.slice(0, 5) 
                    });

                    // Combine dates and times
                    const datetimes = dates.map((date, i) => combineDateTime(date, times[i]));
                    console.log('Combined datetimes (all):', datetimes.slice(0, 5), 'Total length:', datetimes.length);

                    // Filter based on selected comparison and valid datetimes
                    let validIndices;
                    switch (comparisonSelect.value) {
                        case 'RH_AWS vs RH_Manual':
                            validIndices = colC.map((_, i) => datetimes[i] !== null && colC[i] !== null && colD[i] !== null && isFinite(colC[i]) && isFinite(colD[i]));
                            break;
                        case 'Tsec_AWS vs Tsec_Manual':
                            validIndices = colC.map((_, i) => datetimes[i] !== null && colE[i] !== null && colF[i] !== null && isFinite(colE[i]) && isFinite(colF[i]));
                            break;
                        case 'Td_AWS vs Td_Manual':
                            validIndices = colC.map((_, i) => datetimes[i] !== null && colG[i] !== null && colH[i] !== null && isFinite(colG[i]) && isFinite(colH[i]));
                            break;
                        case 'Tmin_AWS vs Tmin_Manual':
                            validIndices = colC.map((_, i) => datetimes[i] !== null && colI[i] !== null && colJ[i] !== null && isFinite(colI[i]) && isFinite(colJ[i]));
                            break;
                        case 'Tmax_AWS vs Tmax_Manual':
                            validIndices = colC.map((_, i) => datetimes[i] !== null && colK[i] !== null && colL[i] !== null && isFinite(colK[i]) && isFinite(colL[i]));
                            break;
                        case 'Rainfall_AWS vs Rainfall_Manual':
                            validIndices = colC.map((_, i) => datetimes[i] !== null && colM[i] !== null && colN[i] !== null && isFinite(colM[i]) && isFinite(colN[i]));
                            break;
                        default:
                            errorMessage.textContent = 'Invalid comparison selected.';
                            console.error('Unknown comparison:', comparisonSelect.value);
                            return;
                    }

                    // Apply date range filter
                    const filteredDatetimes = [];
                    const filteredColC = [];
                    const filteredColD = [];
                    const filteredColE = [];
                    const filteredColF = [];
                    const filteredColG = [];
                    const filteredColH = [];
                    const filteredColI = [];
                    const filteredColJ = [];
                    const filteredColK = [];
                    const filteredColL = [];
                    const filteredColM = [];
                    const filteredColN = [];

                    for (let i = 0; i < datetimes.length; i++) {
                        if (!validIndices[i] || !datetimes[i]) continue;
                        const dt = parseDateTime(datetimes[i]);
                        if (dt && dt >= startDate && dt <= endDate) {
                            filteredDatetimes.push(datetimes[i]);
                            filteredColC.push(colC[i]);
                            filteredColD.push(colD[i]);
                            filteredColE.push(colE[i]);
                            filteredColF.push(colF[i]);
                            filteredColG.push(colG[i]);
                            filteredColH.push(colH[i]);
                            filteredColI.push(colI[i]);
                            filteredColJ.push(colJ[i]);
                            filteredColK.push(colK[i]);
                            filteredColL.push(colL[i]);
                            filteredColM.push(colM[i]);
                            filteredColN.push(colN[i]);
                        }
                    }

                    // Convert filteredDatetimes to Date objects
                    const filteredDates = filteredDatetimes.map(dt => parseDateTime(dt));

                    // Log filtered data for debugging
                    console.log('Filtered datetimes (as Date objects):', filteredDates.map(d => d.toISOString()).slice(0, 5), 'Total filtered length:', filteredDatetimes.length);

                    // Use only the relevant columns for validation
                    let relevantCols;
                    switch (comparisonSelect.value) {
                        case 'RH_AWS vs RH_Manual':
                            relevantCols = [filteredColC, filteredColD];
                            break;
                        case 'Tsec_AWS vs Tsec_Manual':
                            relevantCols = [filteredColE, filteredColF];
                            break;
                        case 'Td_AWS vs Td_Manual':
                            relevantCols = [filteredColG, filteredColH];
                            break;
                        case 'Tmin_AWS vs Tmin_Manual':
                            relevantCols = [filteredColI, filteredColJ];
                            break;
                        case 'Tmax_AWS vs Tmax_Manual':
                            relevantCols = [filteredColK, filteredColL];
                            break;
                        case 'Rainfall_AWS vs Rainfall_Manual':
                            relevantCols = [filteredColM, filteredColN];
                            break;
                    }

                    if (!relevantCols[0] || !relevantCols[1] || relevantCols[0].length < 2 || relevantCols[1].length < 2 || 
                        relevantCols[0].some(v => v === undefined || v === null || !isFinite(v) || typeof v !== 'number') || 
                        relevantCols[1].some(v => v === undefined || v === null || !isFinite(v) || typeof v !== 'number') || 
                        filteredDatetimes.length !== relevantCols[0].length || filteredDatetimes.some(dt => dt === null)) {
                        errorMessage.textContent = 'Insufficient or invalid data in selected date range. At least two rows of numeric data and valid datetimes are required.';
                        console.error('Validation failed:', { relevantCols, filteredDatetimes: filteredDatetimes.slice(0, 5) });
                        return;
                    }

                    // Create plotData using filtered columns
                    const plotData = {
                        colC: filteredColC,
                        colD: filteredColD,
                        colE: filteredColE,
                        colF: filteredColF,
                        colG: filteredColG,
                        colH: filteredColH,
                        colI: filteredColI,
                        colJ: filteredColJ,
                        colK: filteredColK,
                        colL: filteredColL,
                        colM: filteredColM,
                        colN: filteredColN
                    };
                    const rawData = {
                        colC: filteredColC,
                        colD: filteredColD,
                        colE: filteredColE,
                        colF: filteredColF,
                        colG: filteredColG,
                        colH: filteredColH,
                        colI: filteredColI,
                        colJ: filteredColJ,
                        colK: filteredColK,
                        colL: filteredColL,
                        colM: filteredColM,
                        colN: filteredColN
                    };

                    renderPlot(plotData, rawData, filteredDates, comparison[0], comparison[1], sheetName, endDate);
                };

                reader.onerror = function() {
                    errorMessage.textContent = 'Error reading the Excel file.';
                    console.error('File read error');
                };

                reader.readAsArrayBuffer(file);
            });

            // Function to process data and render plot
            function renderPlot(plotData, rawData, datetimes, col1_label, col2_label, sheetName, endDate) {
                console.log('Rendering plot with X-axis datetimes:', datetimes.map(d => d.toISOString()).slice(0, 5), 'Total length:', datetimes.length);

                // Check for sufficient data points
                if (datetimes.length < 2) {
                    document.getElementById('errorMessage').textContent = 'Insufficient data points in selected date range. At least two valid rows are required.';
                    console.error('Insufficient data points:', datetimes.length);
                    return;
                }

                // Derive title based on selected comparison
                const plotTitle = `${sheetName} - ${col1_label} vs ${col2_label}`;

                // Determine y-axis title
                let yAxisTitle = 'Temperature*10 (°C)';
                if (col1_label === 'RH_AWS' && col2_label === 'RH_Manual') {
                    yAxisTitle = 'Humidity (%)';
                } else if (col1_label === 'Rainfall_AWS' && col2_label === 'Rainfall_Manual') {
                    yAxisTitle = 'Rainfall (mm)';
                }

                // Determine plot type
                const isColumnPlot = (col1_label === 'Tmax_AWS' && col2_label === 'Tmax_Manual') || 
                                     (col1_label === 'Rainfall_AWS' && col2_label === 'Rainfall_Manual');

                // Map comparison to specific columns
                let col1_data, col2_data, rawCol1, rawCol2;
                switch (`${col1_label} vs ${col2_label}`) {
                    case 'RH_AWS vs RH_Manual':
                        col1_data = plotData.colC;
                        col2_data = plotData.colD;
                        rawCol1 = rawData.colC;
                        rawCol2 = rawData.colD;
                        break;
                    case 'Tsec_AWS vs Tsec_Manual':
                        col1_data = plotData.colE;
                        col2_data = plotData.colF;
                        rawCol1 = rawData.colE;
                        rawCol2 = rawData.colF;
                        break;
                    case 'Td_AWS vs Td_Manual':
                        col1_data = plotData.colG;
                        col2_data = plotData.colH;
                        rawCol1 = rawData.colG;
                        rawCol2 = rawData.colH;
                        break;
                    case 'Tmin_AWS vs Tmin_Manual':
                        col1_data = plotData.colI;
                        col2_data = plotData.colJ;
                        rawCol1 = rawData.colI;
                        rawCol2 = rawData.colJ;
                        break;
                    case 'Tmax_AWS vs Tmax_Manual':
                        col1_data = plotData.colK;
                        col2_data = plotData.colL;
                        rawCol1 = rawData.colK;
                        rawCol2 = rawData.colL;
                        break;
                    case 'Rainfall_AWS vs Rainfall_Manual':
                        col1_data = plotData.colM;
                        col2_data = plotData.colN;
                        rawCol1 = rawData.colM;
                        rawCol2 = rawData.colN;
                        break;
                    default:
                        document.getElementById('errorMessage').textContent = 'Invalid comparison selected.';
                        console.error('Unknown comparison:', `${col1_label} vs ${col2_label}`);
                        return;
                }

                // Enhanced data validation
                if (!col1_data || !col2_data || !Array.isArray(col1_data) || !Array.isArray(col2_data) || 
                    col1_data.length !== col2_data.length || col1_data.length < 2 || 
                    col1_data.length !== datetimes.length ||
                    col1_data.some(v => v === undefined || v === null || !isFinite(v) || typeof v !== 'number') || 
                    col2_data.some(v => v === undefined || v === null || !isFinite(v) || typeof v !== 'number') ||
                    datetimes.some(dt => dt === null || isNaN(dt.getTime()))) {
                    document.getElementById('errorMessage').textContent = 'Invalid or insufficient data for selected comparison. Ensure at least two numeric values and valid datetimes.';
                    console.error('Data validation failed:', { col1_data: col1_data.slice(0, 10), col2_data: col2_data.slice(0, 10), datetimes: datetimes.map(d => d.toISOString()).slice(0, 10) });
                    return;
                }

                // Log data for debugging
                console.log('Validated plot data for X-axis:', { col1_data: col1_data.slice(0, 5), col2_data: col2_data.slice(0, 5), datetimes: datetimes.map(d => d.toISOString()).slice(0, 5) });

                // Compute dynamic y-axis range based on data
                const allValues = [...col1_data, ...col2_data].filter(v => isFinite(v));
                const minValue = allValues.length > 0 ? Math.min(...allValues) : 0;
                const maxValue = allValues.length > 0 ? Math.max(...allValues) : 1;
                const padding = (maxValue - minValue) * 0.1 || 1;
                const yMin = minValue - padding;
                const yMax = maxValue + padding;
                if (yMin >= yMax) {
                    document.getElementById('errorMessage').textContent = 'Invalid y-axis range. Data may be identical or empty.';
                    console.log('Invalid y-axis range:', { yMin, yMax, minValue, maxValue });
                    return;
                }

                // Compute R^2 to match Excel (based on Pearson correlation)
                function calculateRSquared(arr1, arr2) {
                    const validPairs = arr1.map((v, i) => [v, arr2[i]]).filter(pair => 
                        typeof pair[0] === 'number' && typeof pair[1] === 'number' && isFinite(pair[0]) && isFinite(pair[1]));
                    if (validPairs.length < 2) {
                        console.log('Insufficient valid pairs for R^2:', validPairs.length);
                        return 0;
                    }
                    const n = validPairs.length;
                    const arr1Valid = validPairs.map(pair => pair[0]);
                    const arr2Valid = validPairs.map(pair => pair[1]);
                    const mean1 = arr1Valid.reduce((a, b) => a + b, 0) / n;
                    const mean2 = arr2Valid.reduce((a, b) => a + b, 0) / n;
                    let cov = 0, var1 = 0, var2 = 0;
                    for (let i = 0; i < n; i++) {
                        const dev1 = arr1Valid[i] - mean1;
                        const dev2 = arr2Valid[i] - mean2;
                        cov += dev1 * dev2;
                        var1 += dev1 * dev1;
                        var2 += dev2 * dev2;
                    }
                    const stdDev1 = Math.sqrt(var1 / n);
                    const stdDev2 = Math.sqrt(var2 / n);
                    console.log('Debug - n:', n, 'Means:', { mean1, mean2 }, 'Covariance:', cov / n, 'StdDev1:', stdDev1, 'StdDev2:', stdDev2, 'Raw data sample:', arr1Valid.slice(0, 5), arr2Valid.slice(0, 5));
                    if (stdDev1 === 0 || stdDev2 === 0) {
                        console.log('Zero variance detected, R^2 set to 0');
                        return 0;
                    }
                    const r = (cov / n) / (stdDev1 * stdDev2);
                    const rSquared = r * r;
                    return Number(rSquared.toFixed(4));
                }

                const r_squared = calculateRSquared(rawCol1, rawCol2);
                console.log('Calculated R^2:', r_squared);

                const diffs = col1_data.map((v, i) => Math.abs(v - col2_data[i]));
                const total_records = diffs.length;
                const counts = [
                    diffs.filter(d => d === 0).length,
                    diffs.filter(d => d > 0 && d <= 5).length,
                    diffs.filter(d => d > 5 && d <= 10).length,
                    diffs.filter(d => d > 10 && d <= 15).length,
                    diffs.filter(d => d > 15).length
                ];
                const percentages = counts.map(c => `${(c / total_records * 100).toFixed(1)}%`);
                const labels = ["Diff = 0", "0 < Diff ≤ 5", "5 < Diff ≤ 10", "10 < Diff ≤ 15", "Diff > 15"];
                const table_values = counts.map((c, i) => `${c} (${percentages[i]})`);
                const colors = ['green', 'yellow', 'lightcoral', 'red', 'darkred'];

                const summaryText = `R^2: ${r_squared}<br>` +
                                   `Diff = 0: ${counts[0]} (${percentages[0]})<br>` +
                                   `0 < Diff ≤ 5: ${counts[1]} (${percentages[1]})<br>` +
                                   `5 < Diff ≤ 10: ${counts[2]} (${percentages[2]})<br>` +
                                   `10 < Diff ≤ 15: ${counts[3]} (${percentages[3]})<br>` +
                                   `Diff > 15: ${counts[4]} (${percentages[4]})`;

                // Simplified traces with Date objects for x and spline curves
                const traces = [
                    {
                        x: datetimes,
                        y: col1_data,
                        type: 'scatter',
                        mode: 'lines+markers', // Ensure lines and markers are shown
                        name: col1_label,
                        line: { width: 2, color: 'blue', shape: 'spline' } // Use spline for curves
                    },
                    {
                        x: datetimes,
                        y: col2_data,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: col2_label,
                        line: { width: 2, color: 'orange', shape: 'spline' } // Use spline for curves
                    }
                ];

                // Validate traces
                traces.forEach((trace, index) => {
                    if (!trace.x || !trace.y || trace.x.length < 2 || trace.y.length < 2 || trace.x.length !== trace.y.length) {
                        console.error(`Invalid trace ${index + 1}:`, { x: trace.x.map(d => d.toISOString()), y: trace.y, length: trace.x?.length });
                        document.getElementById('errorMessage').textContent = `Invalid data in trace ${index + 1}. Check console for details.`;
                        return;
                    }
                });

                // Log each trace individually for debugging
                console.log('Trace 1 (AWS) X-axis sample:', JSON.stringify({ ...traces[0], x: traces[0].x.map(d => d.toISOString()).slice(0, 10), y: traces[0].y.slice(0, 10) }, null, 2));
                console.log('Trace 2 (Manual) X-axis sample:', JSON.stringify({ ...traces[1], x: traces[1].x.map(d => d.toISOString()).slice(0, 10), y: traces[1].y.slice(0, 10) }, null, 2));

                // Ensure endDate is valid for toISOString
                const safeEndDate = isNaN(endDate.getTime()) ? new Date('2025-10-19T23:59:59.999Z') : endDate;

                const layout = {
                    title: { text: plotTitle, x: 0.5, xanchor: 'center' },
                    xaxis: {
                        title: 'Date and Time',
                        type: 'date',
                        rangeslider: { visible: true },
                        rangeselector: {
                            buttons: [
                                { count: 1, label: '1d', step: 'day', stepmode: 'backward' },
                                { count: 7, label: '1w', step: 'day', stepmode: 'backward' },
                                { count: 1, label: '1m', step: 'month', stepmode: 'backward' },
                                { step: 'all', label: 'All' }
                            ]
                        },
                        tickformat: '%d/%m/%Y %H:%M',
                        hoverformat: '%d/%m/%Y %H:%M',
                        zoom: true,
                        range: [datetimes[0].toISOString(), datetimes[datetimes.length - 1].toISOString()] // Match data range
                    },
                    yaxis: {
                        title: yAxisTitle,
                        range: [yMin, yMax],
                        zoom: true
                    },
                    hovermode: 'x unified',
                    template: 'plotly_white',
                    width: 1000,
                    height: 700,
                    dragmode: 'zoom',
                    showlegend: true,
                    annotations: [{
                        text: summaryText,
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.5,
                        y: 1.05,
                        showarrow: false,
                        font: { size: 12, color: 'black', family: 'Arial', weight: 'bold' },
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: 'gray',
                        borderwidth: 1,
                        borderpad: 10,
                        align: 'center'
                    }],
                    barmode: isColumnPlot ? 'group' : undefined
                };

                try {
                    Plotly.newPlot('plot', traces, layout);
                    console.log('Plot rendered successfully with X-axis:', datetimes.map(d => d.toISOString()).slice(0, 5));
                } catch (error) {
                    console.error('Error rendering plot:', error);
                    document.getElementById('errorMessage').textContent = 'Error rendering plot. Check console for details.';
                }
            }
        });
    </script>
</body>
</html>